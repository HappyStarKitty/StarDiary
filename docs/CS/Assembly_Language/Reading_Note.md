# Assembly Language
王爽老师的《汇编语言》
## Chap1 基础知识
### 机器语言
机器语言 机器指令的集合
### 汇编语言的产生
汇编源程序 -> 汇编编译器编译为机器码 -> 计算机执行
寄存器 存储数据的器件
### 汇编语言的组成
汇编语言指令
- 汇编指令
机器码的助记符，有对应的机器码
- 伪指令
无对应机器码，由编译器执行，计算机并不执行
- 其他符号
如+、-、*、/等，由编译器识别，无对应机器码
### 存储器
指令和数据在存储器（内存）中存放
### 指令和数据
都是二进制信息
### 存储单元
微机存储器的容量以字节为最小单位
### CPU对存储器的读写
数据读写和外部器件（芯片）进行信息交互
- 地址总线 
存储单元的地址（地址信息）
- 控制总线 
器件的选择，读或写的命令（控制信息）
- 数据总线
读或写的数据（数据信息）
### 地址总线
地址总线 决定寻址能力
### 数据总线
数据总线 决定CPU和外界的数据传送速度
### 控制总线
控制总线 决定CPU对外部器件的控制能力
读信号输出 输出低电平表示将要读取数据
写信号输出 传送写信号
### 内存地址空间
地址总线可寻到的内存单元构成CPU的内存空间
### 主板
主板上的器件通过总线相连
器件 CPU、存储器、外围芯片组、扩展插槽
扩展插槽上插有RAM内存条和各类接口卡
### 接口卡
CPU通过总线向接口卡发送命令
接口卡根据CPU的命令控制外设进行工作
### 各类存储器芯片
- 随机存储器（RAM）
主板上的RAM和插在扩展插槽上的RAM
- 只读存储器（ROM）
装有BIOS（基本输入/输出系统）
- 接口卡上的RAM
对大批量输入输出数据进行暂时存储，如显示卡上的RAM，即显存
### 内存地址空间
物理存储器在逻辑存储器中占有一个地址段，即一段地址空间

---
## Chap2 寄存器
### 通用寄存器
通用寄存器 
AX、BX、CX、DX 16位寄存器
存储一般性的数据
### 字在寄存器中的存储
字节 byte
字 word
### 几条汇编指令
大小写不敏感
mov
add
### 物理地址
物理地址 内存单元构成的存储空间为一维线性空间，每个内存单元有唯一地址
### 8086CPU给出物理地址的方法
物理地址=段地址X16+偏移地址
其他部件（提供段地址和偏移地址）-> 内部总线 -> 地址加法器 （合成物理地址）-> 输入输出控制电路 -> 地址总线 ->内存
### 本质含义
物理地址=基础地址+偏移地址
基础地址=段地址*16
### 段的概念
若干地址连续的内存单元视为一个段
16位地址的寻址能力位64KB,也即一个段的长度最大为64KB
### 段寄存器
段寄存器 CS、DS、SS、ES
### CS和IP
CS 和IP指示CPU当前要读取指令的地方，即CPU将CS：IP指示的内容当作指令执行
CS 代码段寄存器
IP 指令指针寄存器
- 从CS：IP指向的内存单元读取指令，读取指令进入指令缓冲器
- IP=IP+所读取指令的长度，从而指向下一条指令
- 执行指令
### 修改CS、IP的指令
传送指令
- 如mov 
- 不能用于设置CS、IP的值

转移指令 
- 能修改CS、IP的指令
- 如jmp
jmp 段地址：偏移地址 同时修改CS、IP
jmp 某一合法寄存器 用寄存器中的值修改IP
### 代码段
### 实验1
- R 查看、改变CPU寄存器的内容
- D 查看内存中的内容
- E 改写内存中的内容
- U 将内存中的机器指令翻译成汇编指令
- T 执行一条机器指令
- A 以汇编语言的格式在内存中写入一条机器指令

---
## Chap3 寄存器（内存访问）
### 内存中字的存储
字单元
### DS和[address]
mov
- 将数据直接送入寄存器
- 将一个寄存器中的内容送入另一个寄存器
- 将内存单元中的内容送入寄存器
ds为内存单元的段地址
不支持将数据直接送入段寄存器
### 字的传送
注意小端
### mov、add、sub指令
add、sub不能直接对段寄存器进行操作
### 数据段
讲一段内存当作数据段
### 栈
栈的操作规则 LIFO 后进先出
### CPU提供的栈机制
入栈操作和出栈操作均以字为单位
SS：IP指向栈顶元素
push 压入
- SP=SP-2 以当前栈顶前面的单元为新的栈顶
- 将数据送入SS:IP指向的内存单元处，此时SS：SP指向新栈顶
pop 弹出
- 送入数据
- SP=SP+2
### 栈顶超界的问题
需要根据可能用到的最大栈空间安排栈的大小
### push、pop指令
可以对寄存器、段寄存器、内存单元进行操作
### 栈段
### 实验2

---
## Chap4 第一个程序
### 一个源程序从写出到执行的过程
编写（文本文件） -> 编译（目标文件）连接（可执行文件，包括程序和数据、相关的描述信息） -> 执行
### 源程序
#### 伪指令
伪指令是编译器执行的指令
- segment 和 ends 定义段
- end 汇编程序的结束标记
- assume 将特定用途的段与相关的管寄存器关联起来
#### 程序
程序 源程序中最终由计算机执行、处理的数据或指令
#### 标号
指代一个地址
#### 程序的结构
- 定义段
- 写入指令
- 指出程序结束
- 关联段寄存器
#### 程序返回
程序返回 一个程序结束后，将CPU的控制权交还给使它得以运行的程序
mov ax,4c00H
int 21H
#### 语法错误和逻辑错误
### 编辑源程序
edit
### 编译
masm
程序中有Severe Errors
找不到所给出的源程序文件
### 链接
link
### 以简化的方式进行编译和连接
分号
### 执行
### 谁将可执行文件中的程序装载进入内存并使它运行
command加载
### 程序执行过程的跟踪
- ds中存放程序所在内存区的段地址，偏移地址为0
- 内存区前256个字节存放PSP，DOS利用PSP（程序段前缀）来和被加载程序进行通信，向后是程序
### 实验3
---
## Chap5 [BX]和loop指令
### [BX]
inc 自增
### Loop指令
- （cx）=(cx)-1
- 判断cx中的值，不为零则转至标号处，为零则向下执行
cx存放循环次数
### 在Debug中跟踪用loop指令实现的循环程序
在汇编源程序中，数据不能以字母开头
### Debug和汇编编译器masm对指令的不同处理
### loop和[bx]的联合运用
### 段前缀
段前缀 用于显式地知名内存单元的段地址
### 一段安全的空间
### 段前缀的使用
### 实验4
---
## Chap6 包含多个段的程序
### 在代码段中使用数据
dw define world 定义字型数据
end 除了通知编译器程序结束外，还可以通知程序入口在什么地方
### 在代码段中使用栈
### 将数据、代码、栈放入不同的段
### 实验5
---
## Chap7 更灵活的定位内存地址的方法
### and和or指令
and 按位与
or 按位或
### 关于ASCII码
### 以字符形式给出的数据
''转化为ASCII码
### 大小写转换的问题
采用 and和or
### [bx+idata]
### 用[bx+idata]的方式进行数组的处理
### SI和DI
和bx功能相近
### [bx+si]和[bx+di]
### [bx+idata]和[bx+di+idata]
### 不同的寻址方式的灵活应用
### 实验6
---
## Chap8 数据处理的两个基本问题
### bx、si、di和bp
可以用来寻址的寄存器 bx、si、di、bp
可以单个出现，或者以4种组合出现
bx和si、bx和di、bp和si、bp和di
如果使用寄存器bp，而指令中没有显式地给出段地址，段地址默认在si中
### 机器指令处理的数据在什么地方
指令在执行前，处理的数据在3个地方：CPU内部、内存、端口
### 汇编语言中数据位置的表达
立即数 执行前在CPU的指令缓冲器中
寄存器 在寄存器中
段地址（SA）和偏移地址（EA） 段地址可以默认或显性给出
### 寻址方式
- 直接寻址 [idata]
- 寄存器间接寻址 [bx]
- 寄存器相对寻址 结构体 [bx].idata 数组idata[si],二维数组 idata[di] [bx][idata]
- 基址变址寻址 二维数组 [bx][si]
- 相对基址变址寻址 表格（结构）中的数据项 [bx].idata[si] 二维数组 idata[bx][si]
### 指令要处理的数据有多长
- 通过寄存器名指明
- X ptr
### 寻址方式的综合应用
### div指令
- 除数：8位或16位，在一个reg中或内存单元中
- 被除数：默认放在AX或DX和AX中，被除数为16位，则为AX，被除数为32位，AX为低16位，DX存放高16位
- 结果：除数是8位，AL存储商，AH存储余数；除数是16位，AX存储商，DX存储余数
### 伪指令dd
存双字
### dup
db 3 dup (0,1,2)
### 实验7
---
## Chap9 转移指令的原理
段内转移 只修改IP，又可分为近转移和短转移
段间转移 同时修改CS和IP
转移指令可分为：
- 无条件转移指令
- 条件转移指令
- 循环指令
- 过程
- 中断
### 操作符offset
操作符offset取得标号的偏移地址
### jmp指令
转移目的地址
转移距离
### 依据位移进行的jmp指令
jmp short 标号
jmp near ptr 标号
### 转移的目的地址在指令中的jmp指令
jmp far ptr 标号
### 转移地址在寄存器中的jmp指令
jmp 16位reg
### 转移地址在内存中的jmp指令
jmp word ptr 内存单元地址（段内转移）
jmp dword ptr 内存单元地址（段间转移）
### jczx指令
jczx 标号 cx=0则跳
### loop指令
loop 标号 cx-- cx!=0则跳
### 根据位移进行转移的意义
方便程序段在内存中的装配
### 实验8
### 实验9
---
## Chap10 CALL和RET指令
### ret和retf
- ret 
  + 用栈中的数据，修改IP的内容，实现近转移
  + 相当于 pop IP
- retf 
  + 用栈中的数据，修改CS和IP的内容，实现远转移
  + 相当于 pop IP pop CS
### call指令
- 将当前的IP或CS和IP压入栈中
- 转移
### 依据位移进行转移的call指令
call 标号 
将当前IP压栈，转到标号
相当于 push IP jmp near ptr 标号
### 转移目的地址在指令中的call指令
call far ptr 标号
相当于 
push CS
push IP
jmp far ptr 标号
### 转移地址在寄存器中的call指令
call 16位reg
相当于
push IP
jmp 16位reg
### 转移地址在内存中的call指令
call word ptr 内存单元地址
call dword ptr 内存单元地址
### call和ret的配合使用
子程序
### mul指令
与除法类似
mul reg
mul 内存单元
### 模块化程序设计
call和ret实现相互联系、不同层次的子问题
### 参数和结果传递的问题
### 批量数据的传递
### 寄存器冲突的问题
注意出栈和入栈的顺序
### 实验10
--- 
## Chap11 标志存储器
标志寄存器存储的信息是程序状态字（PSW）
### ZF标志
零标志位 若结果为0 zf=1 反之为0
### PF标志
奇偶标志位 结果中所有bit为中1的个数为偶数，pf=1,反之则为0
### SF标志
符号标志位 结果为负，sf=1.反之为0
### CF标志
进位标志位 无符号数运算进位
### OF标志
溢出标志位
### adc指令
带进位加
### sbb指令
带借位减
### cmp指令
比较指令
### 检测比较结果的条件转移指令
je
jne
jb
jnb
ja
jna
### DF标志和串传送指令
df 方向标志位
df=0 每次操作后si、di递增
df=1 每次操作后si、di递减
movsb
movsw
### pushf和popf
pushf 将标志寄存器的值压栈
popf 从栈中弹出数据
### 标志寄存器在Debug中的表示
### 实验11
---
## Chap12 内中断
### 内中断的产生
- 除法错误：0
- 单步执行：1
- 执行into指令：4
- 执行int指令：n
### 中断处理程序
中断类型码定位中断处理程序
### 中断向量表
中断向量 中断处理程序的入口地址
中断向量表 中断处理程序入口地址的列表
一个表项占两个字，高地址字存放段地址，低地址字节存放偏移地址
### 中断过程
- 取得中断类型码
- 标志寄存器的值入栈
- 设置标志寄存器的第8位TF和第9位IF的值为0
- CS的内容入栈
- IP的内容入栈
- 读取中断处理程序的入口地址设置IP和CS
### 中断处理程序和iret指令
- 保存寄存器
- 处理终端
- 恢复寄存器
- 用iret指令返回
pop IP
pop CS
popf
### 除法错误中断的处理
除法溢出
### 编程处理0号中断
### 安装
代码长度 offset do0end-offset do0
### do0
### 设置中断向量
do0入口地址写入中断向量表的0号表项
### 单步中断
单步跟踪程序的执行过程
### 响应中断的特殊情况
### 实验12
---
## int指令
### int指令
中断例程
### 编写供应用程序调用的中断例程
### 对int、iret和栈的深入理解
### BIOS和DOS所提供的中断例程
- 硬件系统的检测和初始化程序
- 外部中断和内部中断的中断例程
- 用于对硬件设备进行I/O操作的中断例程
- 其他和硬件系统相关的中断例程
### BIOS和DOS中断例程的安装过程
### BIOS中断例程应用
(ah)=9 在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数
mov ah,9
mov al,'a'
mov bl,7 ；颜色属性
mov bh,0 ；第0页
mov cx,3 ;字符重复个数
int 10h
### DOS中断例程应用
### 实验13
---
## Chap14 端口
### 端口的读写
in 读取
out 写入
### CMOS RAM芯片
70h为地址端口
71h为数据端口
### shl和shr指令
shl
- 左移
- 最后移出的一位写入CF中
- 最低位用0补充
shr
- 右移
- 最后移出的一位写入CF中
- 最高位用0补充
### CMOS RAM中存储的时间信息
### 实验14
---
## Chap15 外中断
### 接口芯片和端口
CPU通过端口和外部设备进行联系
### 外中断信息
- 可屏蔽中断
- 不可屏蔽中断
sti 设置IF=1
cli 设置IF=0
### PC机键盘的处理过程
- 键盘输入
按键 通码
松键 断码
- 引发9号中断
- 执行int 9 中断例程
### 编写int 9中断例程
### 安装新的int 9中断例程
### 实验15
指令系统
- 数据传送指令
- 算术运算指令
- 逻辑指令
- 转移指令
- 处理机控制指令
- 串处理指令
---
## Chap16
### 描述单元长度的标号
### 在其他段中使用数据标号
seg 操作符 取得某一标号的段地址
### 直接定址表
### 程序入口地址的直接定址表
### 实验16
---
## Chap17 使用BIOS进行键盘输入和磁盘读写
### int 9中断例程对键盘输入的处理
### 使用int 16h中断例程读取键盘缓冲区
### 字符串的输入
### 应用int 13h中断例程对磁盘进行读写
int 13h 访问磁盘
### 实验17
---
